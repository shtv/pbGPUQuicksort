/*
 * Copyright 1993-2009 NVIDIA Corporation.  All rights reserved.
 *
 * NVIDIA Corporation and its licensors retain all intellectual property and 
 * proprietary rights in and to this software and related documentation and 
 * any modifications thereto.  Any use, reproduction, disclosure, or distribution 
 * of this software and related documentation without an express license 
 * agreement from NVIDIA Corporation is strictly prohibited.
 * 
 */

#ifndef _SCAN_WORKEFFICIENT_KERNEL_H_
#define _SCAN_WORKEFFICIENT_KERNEL_H_

///////////////////////////////////////////////////////////////////////////////
//! Work-efficient compute implementation of scan, one thread per 2 elements
//! Work-efficient: O(log(n)) steps, and O(n) adds.
//! Also shared storage efficient: Uses n elements in shared mem -- no ping-ponging
//! Uses a balanced tree type algorithm.  See Blelloch, 1990 "Prefix Sums 
//! and Their Applications", or Prins and Chatterjee PRAM course notes:
//! https://www.cs.unc.edu/~prins/Classes/633/Handouts/pram.pdf
//!
//! Pro: Work Efficient
//! Con: Shared memory bank conflicts due to the addressing used.
//
//! @param g_odata  output data in global memory
//! @param g_idata  input data in global memory
//! @param n        input number of elements to scan from input data
///////////////////////////////////////////////////////////////////////////////

__device__ float is_sorted(const float* keys,int n){
	int thid=threadIdx.x;
	int offset=1;
	extern __shared__ float temp[];
	temp[2*thid]=(keys[2*thid]>keys[2*thid+1])?1:0;
	temp[2*thid+1]=((2*thid+2)<n && keys[2*thid+1]>keys[2*thid+2])?1:0;

  for(int d=n>>1;d>0;d>>=1){
    __syncthreads();
    if(thid<d){
      int ai=offset*(2*thid+1)-1;
      int bi=offset*(2*thid+2)-1;
			temp[bi]+=temp[ai];
    }
    offset<<=1;
  }
  __syncthreads();

	return !temp[n-1];
}

__device__ void seg_copy(float *f,float *keys,float *aseg_flags,float *pivots,unsigned int n)
{
// only pivots modified (exactly set)
  extern  __shared__ float seg_flags[];
  float lastpivot;

  int thid=threadIdx.x;
	seg_flags[2*thid]=aseg_flags[2*thid];
	seg_flags[2*thid+1]=aseg_flags[2*thid+1];
///*	
  int offset=1;
	if(seg_flags[2*thid]) pivots[2*thid]=keys[2*thid];
	else pivots[2*thid]=0;
	if(seg_flags[2*thid+1]) pivots[2*thid+1]=keys[2*thid+1];
	else pivots[2*thid+1]=0;
//	pivots[2*thid]=seg_flags[2*thid];
//	pivots[2*thid+1]=seg_flags[2*thid+1];
//*/
/*
  for(int d=n>>1;d>0;d>>=1){
    __syncthreads();
    if(thid<d){
      int ai=offset*(2*thid+1)-1;
      int bi=offset*(2*thid+2)-1;
      if(!seg_flags[bi])
        pivots[bi]+=pivots[ai];
      seg_flags[bi]=seg_flags[bi]|seg_flags[ai]; // nie rozumiem tego...
    }
    offset<<=1;
  }
*/
/*
  if((thid+1)*2==n){
		lastpivot=pivots[n-1];
    pivots[n-1]=0;
	}
*/
/*
  for(int d=1;d<n;d<<=1){
    offset>>=1;
    __syncthreads();
*/
/*
	  if(thid<d){
	    int ai=offset*(2*thid+1)-1;
	    int bi=offset*(2*thid+2)-1;
	    float t=pivots[ai];
 	  	pivots[ai]=pivots[bi];
 	  	if(seg_flags[ai+1])
 	    	pivots[bi]=0;
 	   	else if(seg_flags[ai])
 	    	pivots[bi]=t;
 	   	else
 	    	pivots[bi]+=t;
	
	    seg_flags[ai]=0; // tego tez nie rozumiem
	  }
  }
*/
/*
  __syncthreads();
	float pivot2=pivots[2*thid+1];
	float pivot3;
	if(thid==n>>1)
		pivot3=lastpivot;
	else
		pivot3=pivots[2*thid+2];
  __syncthreads();
*/
//	pivots[2*thid]=pivot2;
//	pivots[2*thid+1]=pivot3;

//	f:=pivots<=>keys
/*
	float di=keys[2*thid]-pivots[2*thid];
	if(di<0) f[2*thid]=-1;
	else if(di==0) f[2*thid]=0;
	else f[2*thid]=1;
	di=keys[2*thid+1]-pivots[2*thid+1];
	if(di<0) f[2*thid+1]=-1;
	else if(di==0) f[2*thid+1]=0;
	else f[2*thid+1]=1;
*/
//	pivots[2*thid]=2;
//	pivots[2*thid+1]=3;
//  __syncthreads();
}

__global__ void quicksort_kernel(float *g_odata, float *g_idata, int n)
{
  int thid=threadIdx.x;
	extern __shared__ float shared[];
	float* f=(float*) &shared[n];
	float* seg_flags=(float*) &f[n];
	float* pivots=(float*) &seg_flags[n];
//	const int seg_flags=f+sizeof(int)*n;
//	const int pivots=seg_flags+sizeof(int)*n;
	if(thid==0)
		seg_flags[2*thid]=1;
//	else
//		seg_flags[2*thid]=2;
	__syncthreads();

//	is_sorted(g_idata,n);
	g_odata[2*thid]=seg_flags[2*thid];
	g_odata[2*thid+1]=3;//seg_flags[2*thid+1];
	
	__syncthreads();
//	seg_copy(f,g_idata,seg_flags,pivots,n);
//	g_odata[2*thid]=pivots[2*thid];
//	g_odata[2*thid+1]=pivots[2*thid+1];
}

#endif // #ifndef _SCAN_WORKEFFICIENT_KERNEL_H_
