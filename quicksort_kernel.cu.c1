/*
 * Copyright 1993-2009 NVIDIA Corporation.  All rights reserved.
 *
 * NVIDIA Corporation and its licensors retain all intellectual property and 
 * proprietary rights in and to this software and related documentation and 
 * any modifications thereto.  Any use, reproduction, disclosure, or distribution 
 * of this software and related documentation without an express license 
 * agreement from NVIDIA Corporation is strictly prohibited.
 * 
 */

#ifndef _SCAN_WORKEFFICIENT_KERNEL_H_
#define _SCAN_WORKEFFICIENT_KERNEL_H_

///////////////////////////////////////////////////////////////////////////////
//! Work-efficient compute implementation of scan, one thread per 2 elements
//! Work-efficient: O(log(n)) steps, and O(n) adds.
//! Also shared storage efficient: Uses n elements in shared mem -- no ping-ponging
//! Uses a balanced tree type algorithm.  See Blelloch, 1990 "Prefix Sums 
//! and Their Applications", or Prins and Chatterjee PRAM course notes:
//! https://www.cs.unc.edu/~prins/Classes/633/Handouts/pram.pdf
//!
//! Pro: Work Efficient
//! Con: Shared memory bank conflicts due to the addressing used.
//
//! @param g_odata  output data in global memory
//! @param g_idata  input data in global memory
//! @param n        input number of elements to scan from input data
///////////////////////////////////////////////////////////////////////////////

__device__ void is_sorted(float* keys,int* sorted,int n){
	int thid=threadIdx.x;
	if(keys[2*thid]>keys[2*thid+1] || (2*thid==n-1 && keys[2*thid+1]>keys[2*thid+2]))
		*sorted=0;
  __syncthreads();
}

__global__ void quicksort_kernel(float *g_odata, float *g_idata, int n)
{
	int sorted=1;
	is_sorted(g_idata,&sorted,n);
	g_odata[0]=sorted;
}

__global__ void seg_copy(int *f,float *keys,int *aseg_flags,float *pivots,unsigned int n)
{
// only pivots modified (exactly set)
  extern  __shared__ int seg_flags[];
  float lastpivot;

  int thid=threadIdx.x;
	seg_flags[2*thid]=aseg_flags[2*thid];
	seg_flags[2*thid+1]=aseg_flags[2*thid+1];
	
  int offset=1;
	if(seg_flags[2*thid]) pivots[2*thid]=keys[2*thid];
	else pivots[2*thid]=0;
	if(seg_flags[2*thid+1]) pivots[2*thid+1]=keys[2*thid+1];
	else pivots[2*thid+1]=0;

  for(int d=n>>1;d>0;d>>=1){
    __syncthreads();
    if(thid<d){
      int ai=offset*(2*thid+1)-1;
      int bi=offset*(2*thid+2)-1;
      if(!seg_flags[bi])
        pivots[bi]+=pivots[ai];
      seg_flags[bi]=seg_flags[bi]|seg_flags[ai]; // nie rozumiem tego...
    }
    offset<<=1;
  }

  if(thid==n>>1){
		lastpivot=pivots[n-1];
    pivots[n-1]=0;
	}

  for(int d=1;d<n;d<<=1){
    offset>>=1;
    __syncthreads();

	  if(thid<d){
	    int ai=offset*(2*thid+1)-1;
	    int bi=offset*(2*thid+2)-1;
	    float t=pivots[ai];
 	  	pivots[ai]=pivots[bi];
 	  	if(seg_flags[ai+1])
 	    	pivots[bi]=0;
 	   	else if(seg_flags[ai])
 	    	pivots[bi]=t;
 	   	else
 	    	pivots[bi]+=t;
	
	    seg_flags[ai]=0; // tego tez nie rozumiem
	  }
  }
  __syncthreads();
	float pivot2=pivots[2*thid+1];
	float pivot3;
	if(thid==n>>1)
		pivot3=lastpivot;
	else
		pivot3=pivots[2*thid+2];
  __syncthreads();
	pivots[2*thid]=pivot2;
	pivots[2*thid+1]=pivot3;

//	f:=pivots<=>keys
	float di=keys[2*thid]-pivots[2*thid];
	if(di<0) f[2*thid]=-1;
	else if(di==0) f[2*thid]=0;
	else f[2*thid]=1;
	di=keys[2*thid+1]-pivots[2*thid+1];
	if(di<0) f[2*thid+1]=-1;
	else if(di==0) f[2*thid+1]=0;
	else f[2*thid+1]=1;

  __syncthreads();
}



#endif // #ifndef _SCAN_WORKEFFICIENT_KERNEL_H_
